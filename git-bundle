#!/usr/bin/env node
var program = require('commander');
var sh = require('execSync');
var fs = require('fs');
var _ = require('underscore');
var pathComponent = require('path-component');
var table = require('text-table');
var color = require('cli-color');
var ansiTrim = require('cli-color/lib/trim');

var myPath = sh.exec('git config bundle.path').stdout || '.git/bundles'; // Where the bundles directory is located
var myPrefix; // Where we are relative to the root of the project (e.g. 'dir1/dir2/dir3')
// Work out the root directory and change to it - also setting myPrefix {{{
if (fs.existsSync('.git')) {
	myPrefix = '';
} else { // No .git dir - try to find it by poping the dir stack until we hit root
	var myDir = process.cwd().split('/');
	myPrefix = [];
	while (myDir.length) {
		process.chdir(myDir.join('/'));
		if (fs.existsSync('.git')) {
			myPrefix = myPrefix.reverse().join('/') + '/';
			break;
		} else {
			myPrefix.push(myDir.pop());
		}
	}
}
// }}}

// Functions {{{
function getBundles(filters) {
	var bundles = fs.readdirSync(myPath).sort();
	if (filters && filters.length) {
		bundles = _.filter(bundles, function(item) {
			for (var f in filters) {
				if (item == filters[f])
					return 1;
			}
		});
	}
	return bundles;
}
function recurseFS(path, depth, thisDepth) {
	var out = [];
	var files = fs.readdirSync(path).sort();
	for (var f in files) {
		var fullPath = path + '/' + files[f];
		var stats = fs.statSync(fullPath);
		if (files[f] == '.git') {
			// Pass
		} else if (stats.isDirectory()) {
			if (depth > 0 && depth < thisDepth)
				out = out.concat(recurseFS(fullPath, depth, thisDepth + 1));
		} else if (stats.isFile()) {
			out.push(fullPath);
		}
	}
	return out;
}

/**
* Used to boot up all functionality before running a command
* @param bool ensureGit Check for and fatally exit if the current base directory doesnt look like a normal Git project
*/
function init(ensureGit) {
	if (program.path)
		myPath = program.path;
	// Dump remaining args into program.operands
	program.operands = _.filter(program.args, function(i) { return typeof i == 'string' });
	program.operands.shift(); // Assume first arg is always going to be a command
	if (ensureGit && !fs.existsSync('.git')) {
		console.warn('No git repository found in working directory');
		process.exit(1);
	}
}
// }}}

// Global options {{{
program	
	.version('0.0.1')
	.usage('<command>')
	.option('-p, --path <path>', 'Specify the bundle directory (otherwise specified in bundle.path)')
	.option('-v, --verbose', 'Verbosity');
// }}}

// CMD: list {{{
program
	.command('list')
	.usage('[filters...]')
	.description('List all installed bundles')
	.action(function() {
		init(1);
		var bundles = getBundles(program.operands);
		for (var b in bundles) {
			console.log(bundles[b]);
		}
	});
// }}}
// CMD: install {{{
program
	.command('install')
	.usage('[URIs...]')
	.description('Download and install the URI to a bundle')
	.action(function() {
		init(1);
		var existing = getBundles();
		for (var o in program.operands) {
			var name = pathComponent.basename(program.operands[o]).replace(/\.git$/, '');
			if (_.indexOf(existing, name, true) > -1) {
				console.warn('Bundle', name, 'is already installed');
			} else {
				console.log("Installing", name, '...');
				sh.exec("git clone '" + program.operands[o] + "' '" + myPath + "/" + name + "'");
			}
		}
	});
// }}}
// CMD: merge {{{
program
	.command('merge')
	.usage('[bundle...]')
	.description('Merge the bundles into the working project')
	.action(function() {
		init(1);
		var bundles = getBundles(program.operands);
		for (var b in bundles) {
			console.log('Merging', bundles[b], '...');
			var bundlePath = myPath + '/' + bundles[b];
			var files = _.map(recurseFS(bundlePath), function(v) { // Crop file prefix
				return v.substr(bundlePath.length+1);
			});
			for (var f in files) {
				// Check that directory tree exists {{{
				var path = '';
				_.each(pathComponent.dirname(files[f]).split('/'), function(v) {
					path += v;
					if (!fs.existsSync(path))
						fs.mkdirSync(path);
					path += '/';
				});
				// }}}
				sh.run("cp '" + bundlePath + '/' + files[f] + "' './" + files[f] + "'");
			}
		}
	});
// }}}
// CMD: unmerge {{{
program
	.command('unmerge')
	.usage('[bundle...]')
	.description('Merge the bundles into the working project')
	.action(function() {
		init(1);
		var bundles = getBundles(program.operands);
		for (var b in bundles) {
			console.log('Merging', bundles[b], '...');
			var bundlePath = myPath + '/' + bundles[b];
			var files = _.map(recurseFS(bundlePath), function(v) { // Crop file prefix
				return v.substr(bundlePath.length+1);
			});
			for (var f in files) {
				if (fs.existsSync('./' + files[f])) {
					sh.run("cp './" + files[f] + "' '" + bundlePath + '/' + files[f] + "'");
				} else {
					console.warn('File in', bundles[b], 'but not in working project:', files[f]);
				}
			}
		}
	});
// }}}
// CMD: owner {{{
program
	.command('owner')
	.usage('[files...]')
	.description('Show the ownership of files')
	.action(function() {
		init(1);
		var bundles = getBundles();
		var bundleFiles = {};
		if (!program.operands.length) // No files specified - assume all
			program.operands = _.without(fs.readdirSync(myPrefix ? myPrefix : '.'), '.git').sort();
		for (var b in bundles) { // Cache top layer of files using this prefix for each bundle
			var bundleDir = myPath + '/' + bundles[b] + (myPrefix ? '/' + myPrefix : '');
			if (fs.existsSync(bundleDir)) {
				var files = recurseFS(bundleDir, 1);
				bundleFiles[bundles[b]] = {};
				for (var f in files) {
					bundleFiles[bundles[b]][pathComponent.basename(files[f])] = true;
				}
			}
		}
		var tableData = [[color.bold('Bundle(s)'), color.bold('File')]];
		for (var f in program.operands) {
			var owners = [];
			for (var b in bundleFiles) {
				if (program.operands[f] in bundleFiles[b]) {
					owners.push(b);
				}
			}
			tableData.push([owners.length ? owners.join(',') : ' -- ', program.operands[f]]);
		}
		console.log(table(tableData,{
			align: ['c', 'l'],
			stringLength: function(s) { return ansiTrim(s).length }
		}));
	});
// }}}
// CMD: status {{{
program
	.command('status')
	.usage('[bundle...]')
	.description('Show the status of installed bundles')
	.action(function() {
		init(1);
		var myDir = process.cwd();
		var bundles = getBundles(program.operands);
		for (var b in bundles) {
			console.log();
			console.log('BUNDLE', bundles[b]);
			process.chdir(myPath + '/' + bundles[b]);
			sh.run("git status");
			process.chdir(myDir);
		}
	});
// }}}
// CMD: debug {{{
program
	.command('debug')
	.description('Show config information')
	.action(function() {
		init();
		console.log('CWD/Base', process.cwd());
		console.log('Path', myPath);
		console.log('Prefix', myPrefix);
	});
// }}}
// CMD: Else {{{
program
	.command('*')
	.action(function() {
		init();
		console.warn('Unknown command');
	});
// }}}

program.parse(process.argv);
