#!/usr/bin/env node
var program = require('commander');
var sh = require('execSync');
var fs = require('fs');
var _ = require('underscore');
var pathComponent = require('path-component');

var myPath = sh.exec('git config bundle.path').stdout || '.git/bundles';

// Functions {{{
function getBundles(filters) {
	var bundles = fs.readdirSync(myPath).sort();
	if (filters && filters.length) {
		bundles = _.filter(bundles, function(item) {
			for (var f in filters) {
				if (item == filters[f])
					return 1;
			}
		});
	}
	return bundles;
}
function recurseFS(path) {
	var out = [];
	var files = fs.readdirSync(path).sort();
	for (var f in files) {
		var fullPath = path + '/' + files[f];
		var stats = fs.statSync(fullPath);
		if (files[f] == '.git') {
			// Pass
		} else if (stats.isDirectory()) {
			out = out.concat(recurseFS(fullPath));
		} else if (stats.isFile()) {
			out.push(fullPath);
		}
	}
	return out;
}
// }}}

// Global options {{{
program	
	.version('0.0.1')
	.usage('<command>')
	.option('-p, --path <path>', 'Specify the bundle directory (otherwise specified in bundle.path)')
	.option('-v, --verbose', 'Verbosity')
	.parse(process.argv);

if (program.path)
	myPath = program.path;

// Dump remaining args into program.operands
program.operands = _.filter(program.args, function(i) { return typeof i == 'string' });
program.operands.shift(); // Assume first arg is always going to be a command
// }}}

// CMD: list {{{
program
	.command('list')
	.usage('[filters...]')
	.description('List all installed bundles')
	.action(function() {
		var bundles = getBundles(program.operands);
		for (var b in bundles) {
			console.log(bundles[b]);
		}
	});
// }}}
// CMD: install {{{
program
	.command('install')
	.usage('[URIs...]')
	.description('Download and install the URI to a bundle')
	.action(function() {
		var existing = getBundles();
		for (var o in program.operands) {
			var name = pathComponent.basename(program.operands[o]).replace(/\.git$/, '');
			if (_.indexOf(existing, name, true) > -1) {
				console.warn('Bundle', name, 'is already installed');
			} else {
				console.log("Installing", name, '...');
				sh.exec("git clone '" + program.operands[o] + "' '" + myPath + "/" + name + "'");
			}
		}
	});
// }}}
// CMD: merge {{{
program
	.command('merge')
	.usage('[bundle...]')
	.description('Merge the bundles into the working project')
	.action(function() {
		var bundles = getBundles(program.operands);
		for (var b in bundles) {
			console.log('Merging', bundles[b], '...');
			var bundlePath = myPath + '/' + bundles[b];
			var files = _.map(recurseFS(bundlePath), function(v) { // Crop file prefix
				return v.substr(bundlePath.length+1);
			});
			for (var f in files) {
				// Check that directory tree exists {{{
				var path = '';
				_.each(pathComponent.dirname(files[f]).split('/'), function(v) {
					path += v;
					if (!fs.existsSync(path))
						fs.mkdirSync(path);
					path += '/';
				});
				// }}}
				sh.run("cp '" + bundlePath + '/' + files[f] + "' './" + files[f] + "'");
			}
		}
	});
// }}}
// CMD: unmerge {{{
program
	.command('unmerge')
	.usage('[bundle...]')
	.description('Merge the bundles into the working project')
	.action(function() {
		var bundles = getBundles(program.operands);
		for (var b in bundles) {
			console.log('Merging', bundles[b], '...');
			var bundlePath = myPath + '/' + bundles[b];
			var files = _.map(recurseFS(bundlePath), function(v) { // Crop file prefix
				return v.substr(bundlePath.length+1);
			});
			for (var f in files) {
				if (fs.existsSync('./' + files[f])) {
					sh.run("cp './" + files[f] + "' '" + bundlePath + '/' + files[f] + "'");
				} else {
					console.warn('File in', bundles[b], 'but not in working project:', files[f]);
				}
			}
		}
	});
// }}}

program
	.command('debug')
	.description('Show config information')
	.action(function() {
		console.log('Path', myPath);
	});

program
	.command('*')
	.action(function() {
		console.warn('Unknown command');
	});

program.parse(process.argv);
